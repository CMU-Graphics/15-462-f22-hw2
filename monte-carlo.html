<!doctype html>
<html>
<head>
<title>Monte Carlo Integration</title>

<style>
html, body, h1, h2, p { padding: 0; margin: 0; }
html { border-top:25px solid #b00; }
body {
	font-family: 'Open Sans', sans-serif;
	font-style: normal;
	font-size: 12pt;
	font-weight: 400;
	color: #000;
	padding:0 2em 0 2em;
}

h1, h2 {
	font-size: 24pt;
	font-weight: 700;
	margin:0 auto 14px auto;
}
h1 { text-transform: uppercase; margin-bottom: 5px; }
h2 { font-size: 16pt; }

p, h1, h2 { max-width: 700px; }
p { 
	color: #505050;
	margin:0 auto 1em auto;
}

.highlight { color: #b00; }
.column-container {
	display: grid;
    grid-template-columns: auto auto;
    /* gap: 10px 50px; */
    background-color: white;
	padding: 0 10% 0 10%;
}

</style>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>

<h1>Monte Carlo Integration</h1>
<h2>CMU 15-462/662 Fall 2022 | <span class="highlight">Mini-HW</span></h2>

<p>
(Assignment description)
</p>

<div id="wrapper" class="column-container">
<canvas id="canvas" width="500px" height="300px"></canvas>

<div>
	<div>
	<label>a:</label>
	<input id="a_input" type="number">
	</div>
	
	<div>
	<label>b:</label>
	<input id="b_input" type="number">
	</div>
	
	<div>
	<label>N:</label>
	<input id="N_input" type="number">
	</div>
	
	<div>
	<button id="resample_button" onclick="update()">Resample</button>
	</div>
	
	<div id="num_int_value">
		<!-- Numerical Integration: -->
		$$\int_a^b f(x) =$$ 
	</div>
		
	<div id="avg_value">
		<!-- Function Average without divison by pdf: -->
		$$\frac{1}{n}\sum\limits_{i=1}^n f(s) =$$
	</div>
	
	<div id="pdf_avg_value">
		<!-- Function Average with division by pdf: -->
		$$\frac{1}{n}\sum\limits_{i=1}^n \frac{f(s)}{pdf(s)} =$$
	</div>
</div>
</div>

<script>
"use strict";
//-----------------------------------------------------------------

const WRAPPER = document.getElementById('wrapper');
const CANVAS = document.getElementById('canvas');
const CTX = CANVAS.getContext('2d');

var Width = CANVAS.width;
var Height = CANVAS.height;
var a = -5;
var b = 2;

// graph space settings
const MAX_X = 10;
const MIN_X = -10;
const MAX_Y = MAX_X * Height / Width;
const MIN_Y = MIN_X * Height / Width;
const STEP_X = 1;
const STEP_Y = 1;

var DX = (MAX_X - MIN_X) / Width;
var DY = (MAX_Y - MIN_Y) / Height;

const F_COLOR = "green";
const PDF_COLOR = "red";

const EPS = 0.00001
 
// default function to graph
var F = function(x) { 
	// return Math.sin(x) + 1;
	return x;
	// arbitrary function
	// return (x - 2) * (x - 1) * x * (x + 1) * (x + 2) + 4;
}

// pdf to estimate function F
var pdf = function(x) {
	return 0.5 * x;
}

window.onload = draw;

// x in graph space -> x in canvas space
function xToCanvas(x) {
  return (x - MIN_X) / (MAX_X - MIN_X) * Width;
}

// y in graph space -> y in canvas space
function yToCanvas(y) {
  return Height - (y - MIN_Y) / (MAX_Y - MIN_Y) * Height;
}

/* Integration calculations */

function numerical(f, n, lo, hi) {
	// trapezoid rule
	let dx = (hi - lo) / n;
	let sum = 0;
	let xprev = lo;
	for (let i = 0; i < n; i++) {
		let x0 = xprev;
		let x1 = x0 + dx;
		let y0 = f(x0);
		let y1 = f(x1);
		sum += ((Math.abs(y0) + Math.abs(y1)) * dx * 0.5)
		xprev = x1;
	}

	return sum;
}

function average(f, n, lo, hi) {
	// no pdf, all samples weighted equally
	let dx = (hi - lo) / n;
	let x = lo;
	let sum = 0;
	for (let i = 0; i < n; i++) {
		sum += f(x);
		x += dx;
	}

	return sum / n;
}

function pdfAverage(f, n, lo, hi, p) {
	// samples weighted by pdf values
	let dx = (hi - lo) / n;
	let x = lo;
	let sum = 0;
	for (let i = 0; i < n; i++) {
		let w = (p(x) === 0) ? EPS : p(x);
		sum += (f(x) / w);
		x += dx;
	}

	return sum / n;
}

/* Rendering functions */

function update() {
	a = parseInt(document.getElementById("a_input").value);
	b = parseInt(document.getElementById("b_input").value);
	if (a >= b) {
		// TODO: display an error message on screen
		console.log("bad bounds");
	}

	let n = parseInt(document.getElementById("N_input").value);
	// TODO: set a threshold for n
	
	let numSumElem = document.getElementById("num_int_value");
	numSumElem.innerHTML = "$$\\int_a^b f(x) =" + `${numerical(F, n, a, b)}$$`;

	let avgElem = document.getElementById("avg_value");
	avgElem.innerHTML = "$$\\frac{1}{n}\\sum\\limits_{i=1}^n f(s) =" + `${average(F, n, a, b)}$$`;

	let pdfAvgElem = document.getElementById("pdf_avg_value");
	pdfAvgElem.innerHTML = "$$\\frac{1}{n}\\sum\\limits_{i=1}^n \\frac{f(s)}{pdf(s)} =" + `${pdfAverage(F, n, a, b, pdf)}$$`;

	MathJax.typesetClear([numSumElem, avgElem, pdfAvgElem]);
	MathJax.typeset([numSumElem, avgElem, pdfAvgElem]);

	draw();
}

function draw() {
	CTX.clearRect(0, 0, Width, Height);

	drawAxes();
	drawFunction(F, F_COLOR);
	drawFunction(pdf, PDF_COLOR);
	drawBounds(a, b);
}

// draws the X ad Y axes with tick marks
function drawAxes() {
	CTX.save();
	CTX.lineWidth = 2;

	CTX.beginPath();
	CTX.moveTo(xToCanvas(0),yToCanvas(MIN_Y));
	CTX.lineTo(xToCanvas(0),yToCanvas(MAX_Y));
	CTX.stroke();

	CTX.beginPath();
	CTX.moveTo(xToCanvas(MIN_X),yToCanvas(0));
	CTX.lineTo(xToCanvas(MAX_X),yToCanvas(0));
	CTX.stroke();

	// drawTickMarks();

	CTX.restore();
}

function drawTickMarks() {
	// Y axis tick marks
	var delta = STEP_Y;
	for (var i = 1; (i * delta) < MAX_Y; ++i) {
		CTX.beginPath();
		CTX.moveTo(xToCanvas(0) - 5,yToCanvas(i * delta));
		CTX.lineTo(xToCanvas(0) + 5,yToCanvas(i * delta));
		CTX.stroke();  
	}

	var delta = STEP_Y;
	for (var i = 1; (i * delta) > MIN_Y; --i) {
		CTX.beginPath();
		CTX.moveTo(xToCanvas(0) - 5,yToCanvas(i * delta));
		CTX.lineTo(xToCanvas(0) + 5,yToCanvas(i * delta));
		CTX.stroke();  
	}  
	
	// X tick marks
	var delta = STEP_X;
	for (var i = 1; (i * delta) < MAX_X; ++i) {
		CTX.beginPath();
		CTX.moveTo(xToCanvas(i * delta),yToCanvas(0)-5);
		CTX.lineTo(xToCanvas(i * delta),yToCanvas(0)+5);
		CTX.stroke();  
	}

	var delta = STEP_X;
	for (var i = 1; (i * delta) > MIN_X; --i) {
		CTX.beginPath();
		CTX.moveTo(xToCanvas(i * delta),yToCanvas(0)-5);
		CTX.lineTo(xToCanvas(i * delta),yToCanvas(0)+5);
		CTX.stroke();  
	}
}

function drawFunction(f, style) {
	CTX.save();

	CTX.beginPath();
	CTX.strokeStyle = style;
	CTX.moveTo(xToCanvas(MIN_X), yToCanvas(f(MIN_X)));
	for (let x = MIN_X + DX; x <= MAX_X; x += DX) {
		CTX.lineTo(xToCanvas(x), yToCanvas(f(x)));
	}
	CTX.stroke();

	CTX.restore();
}

function drawBounds(lo, hi) {
	CTX.save();

	CTX.beginPath();
	CTX.moveTo(xToCanvas(lo), yToCanvas(MIN_Y));
	CTX.lineTo(xToCanvas(lo), yToCanvas(MAX_Y));
	CTX.stroke();

	CTX.beginPath();
	CTX.moveTo(xToCanvas(hi), yToCanvas(MIN_Y));
	CTX.lineTo(xToCanvas(hi), yToCanvas(MAX_Y));
	CTX.stroke();

	CTX.restore();
}

</script>
</body>
</html>
