<!doctype html>
<html>
<head>
<title>Monte Carlo Integration</title>

<style>
html, body, h1, h2, p { padding: 0; margin: 0; }
html { border-top:25px solid #b00; }
body {
	font-family: 'Open Sans', sans-serif;
	font-style: normal;
	font-size: 12pt;
	font-weight: 400;
	color: #000;
	padding:0 2em 0 2em;
}

h1, h2 {
	font-size: 24pt;
	font-weight: 700;
	margin:0 auto 14px auto;
}
h1 { text-transform: uppercase; margin-bottom: 5px; }
h2 { font-size: 16pt; }

p, h1, h2 { max-width: 700px; }
p { 
	color: #505050;
	margin:0 auto 1em auto;
}

.highlight { color: #b00; }
.column-container {
	display: grid;
    grid-template-columns: auto auto;
    background-color: white;
	padding: 0 10% 0 10%;
}

.row-container {
	display: grid;
	grid-template-rows: auto;
	background-color: white;
	padding: auto 0 auto 0;
	gap: 20px 0;
}

.center {
	margin: auto;
}

.error {
	margin: auto;
	color: red;
}

button {
    font-size: large;
	border: none;
	color: white;
    background-color: #b00;;
    width: 6em;
    height: 2em;
}

</style>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>

<h1>Monte Carlo Integration</h1>
<h2>CMU 15-462/662 Fall 2022 | <span class="highlight">Mini-HW</span></h2>

<p>
(Assignment description)
</p>

<div id="wrapper" class="column-container">
<canvas id="canvas-top" width="600px" height="350px"></canvas>

<div>
	<div class="row-container">
	<div class="center">
		Input lower bound \(a\), upper bound \(b(-10\le a&lt;b\le 10)\), and the number of samples \(n(1\le n\le 1000)\) below, then click "Resample":
	</div>

	<div id="error_msg" class="error"></div>
	
	<div id="lower" class="center">
	<label>\(a:\)</label>
	<input id="a_input" type="number" value="-5">
	</div>
	
	<div id="higher" class="center">
	<label>\(b:\)</label>
	<input id="b_input" type="number" value="5">
	</div>
	
	<div id="samples" class="center">
	<label>\(n:\)</label>
	<input id="N_input" type="number" value="10">
	</div>
	
	<div class="center">
	<button id="resample_button" onclick="update()">Resample</button>
	</div>

	<div id="math" class="center">
		$$\begin{aligned}
			\int_a^b f(x) &= \\ 
			\frac{1}{n}\sum\limits_{i=1}^n f(s) &= \\ 
			\frac{1}{n}\sum\limits_{i=1}^n \frac{f(s)}{pdf(s)} &= 
		\end{aligned}$$
	</div>
	</div>

</div>

<canvas id="canvas-bot" width="1000px" height="350px"></canvas>
</div>

<script>
"use strict";
//-----------------------------------------------------------------
// Helpful global variables

const TOP_CANVAS = document.getElementById('canvas-top');
const BOT_CANVAS = document.getElementById('canvas-bot');

const INTEGRAL_SAMPLES = 1000;
const MAX_N = 1000;
const EPS = 0.00001

// graph space settings
const MAX_X = 10;
const MIN_X = -10;
const MAX_Y = 10;
const MIN_Y = -5;
const PROB_SCALE = 10; //how much to scale probabilities when displaying on the axes

// graph styling settings
const F_COLOR = "green";
const WEIGHTS_COLOR = "#b1b";
const PDF_COLOR = "red";
const BOUNDS_COLOR = "blue";
const LABEL_FONT = "18px Serif";
const COLOR_YELLOW = [255, 255, 0];
const COLOR_ORANGE = [255, 165, 0];
const COLOR_GREEN = [0, 255, 0];
const COLOR_BLUE = [0, 0, 255];


// tick marks settings
const TICK_MARK_OFFSET = 2.5;
const STEP_X = 1;
const STEP_Y = 1;

var TopCanvas;
var BottomCanvas;

// CHANGE THIS: default function to graph
const F = function(x) { 
	return 2 * Math.sin(x) + 3;
}

// CHANGE THIS: weights for various positions to sample from when estimating function integral over [lo, hi]
const weights = function(x, lo, hi) {
	return 2 * Math.sin(x) + 2.6;
}

//helper to build a sampler from weightsFn() function over range [lo, hi]:
class Sampler {
	constructor(weightsFn, lo, hi, fillRGB) {
		this.BINS = 100;

		//will actually sample from a piecewise-uniform distribution over 1000 bins:
		this.lo = lo;
		this.hi = hi;

		//for plotting
		this.fillRGB = fillRGB;

		//get weights at bin centers:
		let total = 0.0;
		let weights = [];
		for (let i = 0; i < this.BINS; ++i) {
			const x = (i + 0.5) / this.BINS * (this.hi - this.lo) + this.lo;
			const w = Math.max(weightsFn(x), 0);
			weights.push(w);
			total += w;
		}
		//quantize weights and recompute total to make math a bit easier:
		const TARGET_TOTAL = 1e9 * this.BINS; //64-bit floating point has about 53 bits of integer precision; this is about 30 bits per bin, so plenty of headroom
		let subtotal = 0.0;
		for (let i = 0; i < this.BINS; ++i) {
			const before = Math.round(TARGET_TOTAL * (subtotal / total));
			subtotal += weights[i];
			const after = Math.round(TARGET_TOTAL * (subtotal / total));
			weights[i] = after - before;
		}

		//set probabilities to reflect quantized weights:
		this.probs = [];
		for (let i = 0; i < weights.length; ++i) {
			this.probs.push(weights[i] / TARGET_TOTAL);
		}

		//quick sanity check:
		total = 0;
		for (let i = 0; i < this.BINS; ++i) {
			total += weights[i];
		}
		console.assert(total === TARGET_TOTAL, `Weight quantization worked properly (${total} == ${TARGET_TOTAL}).`);

		//Okay, now weights sum to TARGET_TOTAL.
		//Divide them into uniformly-weighted coin flips with the alias method:

		const AVERAGE = TARGET_TOTAL / this.BINS;

		let over = [];
		let under = [];
		for (let i = 0; i < this.BINS; ++i) {
			let option = {i:i, w:weights[i]};
			if (option.w < AVERAGE) under.push(option);
			else over.push(option);
		}

		//now pair up small and large probabilities into options with exactly AVERAGE weight:
		this.options = [];
		while (over.length > 0) {
			let o = over.pop();
			if (under.length === 0) {
				//output an option where both secondary choices are i:
				this.options.push({a:o.i, b:o.i, split:0.0});
				o.w -= AVERAGE;
			} else {
				let u = under.pop();
				this.options.push({a:u.i, b:o.i, split:u.w/AVERAGE});
				o.w -= (AVERAGE - u.w);
			}
			console.assert(o.w >= 0, "Shouldn't take more weight than available.");
			if (o.w >= AVERAGE) over.push(o);
			else if (o.w > 0) under.push(o);
		}
		if (under.length > 0) {
			console.warn("Hmm, have some leftover probability mass. Strange. Sampling might be a tad odd.");
			for (let i = 0; i < under.length; ++i) {
				console.log(`${JSON.stringify(under[i])} vs ${AVERAGE}`);
			}
		}
	}
	pdf(x) {
		let i = Math.floor((x - this.lo) / (this.hi - this.lo) * this.BINS);
		if (i < 0 || i >= this.BINS) return 0.0;
		const w = (this.hi - this.lo) / this.BINS; //width of a bin
		return this.probs[i] / w;

	}
	sample() {
		window.last_sampler = this; //DEBUG
		//get option uniformly at random:
		const oi = Math.floor(Math.random() * this.options.length);
		const o = this.options[ oi ];
		//get corresponding bin based on option's split point:
		const i = (Math.random() < o.split ? o.a : o.b);
		//sample uniformly within the bin:
		return (this.hi - this.lo) * ((i + Math.random()) / this.BINS) + this.lo;
	}
}


// x in graph space -> x in canvas space
function xToCanvas(x, Width) {
  return (x - MIN_X) / (MAX_X - MIN_X) * Width;
}

// y in graph space -> y in canvas space
function yToCanvas(y, Height) {
  return (1 - (y - MIN_Y) / (MAX_Y - MIN_Y)) * Height;
}

//-----------------------------------------------------------------
// Integration and sum calculations

function numerical(f, n, lo, hi) {
	// trapezoid rule
	let sum = 0;
	const dx = (hi - lo) / n;
	for (let i = 0; i < n; i++) {
		let x0 = (i / n) * (hi - lo) + lo;
		let x1 = ((i+1) / n) * (hi - lo) + lo;
		let y0 = f(x0);
		let y1 = f(x1);
		sum += ((y0 + y1) * dx * 0.5)
	}

	return sum;
}

function average(f, lo, hi, samples) {
	// no pdf, all samples weighted equally
	let sum = 0;
	for (let i = 0; i < samples.length; i++) {
		let s = samples[i];
		if (s >= lo && s <= hi) {
			sum += f(s);
		}
	}
	return sum / samples.length;
}

function pdfAverage(f, lo, hi, samples, probs) {
	// samples weighted by pdf values
	let sum = 0;
	for (let i = 0; i < samples.length; i++) {
		let s = samples[i];
		let p = probs[i];
		if (s >= lo && s <= hi) {
			sum += f(s) / p;
		}
	}
	return sum / samples.length;
}

//-----------------------------------------------------------------
// Rendering functions
function init() {  
	TopCanvas = new DistributionRenderer(TOP_CANVAS)
	BottomCanvas = new DistributionRenderer(BOT_CANVAS)
	update()
}


function update() {
	let errorElem = document.getElementById("error_msg");
	errorElem.innerHTML = "";
	let lo = parseInt(document.getElementById("a_input").value);
	let hi = parseInt(document.getElementById("b_input").value);
	let n = parseInt(document.getElementById("N_input").value);

	if (!(lo === lo) || !(hi === hi) || !(n === n)) {
		errorElem.innerHTML = "Please enter all the fields!";
		return;
	}
	
	if (lo < MIN_X || hi > MAX_X || lo >= hi) {
		errorElem.innerHTML = "Invalid a and b values!";
		return;
	}

	if (n <= 0 || n > MAX_N) {
		errorElem.innerHTML = "Invalid n value!";
		return;
	}
	
	let sampler = new Sampler(weights, lo, hi, COLOR_GREEN);

	displayMath(n, lo, hi, sampler);
	TopCanvas.draw(lo, hi, [sampler]);

	const weights_1 = function(x, lo ,hi) { return 2 * Math.cos(x) + 2.6 }
	const weights_2 = function(x, lo, hi) { return x }
	const sampler_1 = new Sampler(weights_1, lo, hi, COLOR_YELLOW);
	const sampler_2 = new Sampler(weights_2, lo, hi, COLOR_BLUE);
	BottomCanvas.draw(lo, hi, [sampler, sampler_1, sampler_2]);
}

function displayMath(n, lo, hi, sampler) {
	//sample locations:
	let samples = [];
	let probs = [];
	for (let i = 0; i < n; ++i) {
		let s = sampler.sample();
		samples.push(s);
		probs.push(sampler.pdf(s));
	}
	//also, save for later display:
	sampler.INFO = {samples: samples, probs:probs};

	//compute values:
	let str = "$$\\begin{aligned}";
	str += ("\\int_a^b f(x) &=" + `${numerical(F, INTEGRAL_SAMPLES, lo, hi)}\\\\`);
	str += ("\\frac{1}{n}\\sum\\limits_{i=1}^n f(s) &=" + `${average(F, lo, hi, samples)}\\\\`);
	str += ("\\frac{1}{n}\\sum\\limits_{i=1}^n \\frac{f(s)}{pdf(s)} &=" + `${pdfAverage(F, lo, hi, samples, probs)}`);
	str += "\\end{aligned}$$";

	let mathElem = document.getElementById("math");
	mathElem.innerHTML = str;
	MathJax.typesetClear([mathElem]);
	MathJax.typeset([mathElem]);
}


class DistributionRenderer {  
	constructor(HTMLCanvas) {  
		this.CANVAS = HTMLCanvas;
		this.CTX = HTMLCanvas.getContext("2d");
		this.Width = HTMLCanvas.width;
		this.Height = HTMLCanvas.height;
		// step size for graphing functions
		this.DX = (MAX_X - MIN_X) / this.Width;
		this.DY = (MAX_Y - MIN_Y) / this.Height;
	}

	draw(a, b, samplers) {  
		this.CTX.clearRect(0, 0, this.Width, this.Height);
		drawAxes(this.CTX, this.Width, this.Height);
		drawFunction(this.CTX, F, F_COLOR, this.Width, this.Height, this.DX, this.DY);
		drawFunction(this.CTX, weights, WEIGHTS_COLOR, this.Width, this.Height, this.DX, this.DY);
		
		for (let i = 0; i < samplers.length; i ++) {  
			drawSampler(this.CTX, samplers[i], this.Width, this.Height);
			drawFunction(this.CTX, (x) => PROB_SCALE * samplers[i].pdf(x), PDF_COLOR, this.Width, this.Height, this.DX, this.DY);
		}
		
		drawBounds(this.CTX, a, b, this.Width, this.Height);
		drawLegend(this.CTX, this.Width, this.Height);
	}
}

function draw(a, b, sampler) {
	CTX.clearRect(0, 0, Width, Height);

	drawAxes();
	drawFunction(F, F_COLOR);
	drawFunction(weights, WEIGHTS_COLOR);
	drawSampler(sampler, "yellow");
	drawFunction((x) => PROB_SCALE * sampler.pdf(x), PDF_COLOR);

	drawBounds(a, b);
	drawLegend();
}

// draws the X ad Y axes with tick marks
function drawAxes(CTX, Width, Height) {
	console.log("Input: ", CTX, Width, Height)
	CTX.save();
	CTX.lineWidth = 2;
	
	// x axis
	CTX.beginPath();
	CTX.moveTo(0, yToCanvas(0, Height)); 
	CTX.lineTo(Width, yToCanvas(0, Height));
	CTX.stroke();
	CTX.font = LABEL_FONT;
	CTX.fillStyle = "black";
	CTX.fillText("x", Width - 10, 0.72 * Height);

	// y axis
	CTX.beginPath();
	CTX.moveTo(xToCanvas(0, Width), 0);
	CTX.lineTo(xToCanvas(0, Width), Height);
	CTX.stroke();
	CTX.font = LABEL_FONT;
	CTX.fillStyle = "black";
	CTX.fillText("y", 0.5 * Width + 10, 15);

	// Y axis tick marks
	for (let yi = MIN_Y; yi <= MAX_Y; yi += STEP_Y) {
		CTX.beginPath();
		CTX.moveTo(xToCanvas(0, Width) - TICK_MARK_OFFSET, yToCanvas(yi, Height));
		CTX.lineTo(xToCanvas(0, Width) + TICK_MARK_OFFSET, yToCanvas(yi, Height));
		CTX.stroke();  
	}
	
	// X tick marks
	for (let xi = MIN_X; xi <= MAX_X; xi += STEP_X) {
		CTX.beginPath();
		CTX.moveTo(xToCanvas(xi, Width), yToCanvas(0, Height) - TICK_MARK_OFFSET);
		CTX.lineTo(xToCanvas(xi, Width), yToCanvas(0, Height) + TICK_MARK_OFFSET);
		CTX.stroke();   
	}
	
	CTX.restore();
}

function drawSampler(CTX, sampler, Width, Height) {
	CTX.save();

	/* //skipping -- already have sampler.pdf() drawn
	//draw the reported (via 'probs') distribution of the sampler:
	CTX.beginPath();
	CTX.moveTo( xToCanvas(sampler.lo) , yToCanvas(0.0) );
	for (let i = 0; i < sampler.BINS; ++i) {
		let x0 = xToCanvas( (sampler.hi - sampler.lo) * i / sampler.BINS + sampler.lo );
		let x1 = xToCanvas( (sampler.hi - sampler.lo) * (i+1) / sampler.BINS + sampler.lo );

		let y = yToCanvas( sampler.probs[i] * PROB_SCALE );

		CTX.lineTo(x0, y);
		CTX.lineTo(x1, y);
	}
	CTX.lineTo( xToCanvas(sampler.hi) , yToCanvas(0.0) );
	CTX.strokeStyle = '#888';
	CTX.stroke();
	CTX.closePath();

	CTX.fillStyle = '#8881';
	CTX.fill();
	*/

	//draw an empirical (via a bunch of samples) distribution for the sampler:
	let counts = [];
	for (let i = 0; i < 10; ++i) {
		counts.push(0);
	}

	const SAMPLES = 10000;
	let outside = 0;
	for (let i = 0; i < SAMPLES; ++i) {
		const b = Math.floor( (sampler.sample(i) - sampler.lo) / (sampler.hi - sampler.lo) * counts.length );
		if (b >= 0 && b < counts.length) {
			counts[b] += 1;
		}
	}

	CTX.beginPath();
	CTX.moveTo( xToCanvas(sampler.lo, Width) , yToCanvas(0.0, Height) );
	for (let i = 0; i < sampler.BINS; ++i) {
		let x0 = xToCanvas( (sampler.hi - sampler.lo) * i / counts.length + sampler.lo, Width );
		let x1 = xToCanvas( (sampler.hi - sampler.lo) * (i+1) / counts.length + sampler.lo, Width );

		let dx = (sampler.hi - sampler.lo) / counts.length;

		let y = yToCanvas( counts[i] / SAMPLES / dx * PROB_SCALE , Height);

		CTX.lineTo(x0, y);
		CTX.lineTo(x1, y);
	}
	CTX.lineTo( xToCanvas(sampler.hi, Width) , yToCanvas(0.0, Height) );
	CTX.strokeStyle = '#880';
	CTX.stroke();
	CTX.closePath();
	console.log(sampler.fillRGB)
	var [r, g, b] = sampler.fillRGB // color of area under the curve
	CTX.fillStyle = `rgba(${r}, ${g}, ${b}, 0.5)`;
	CTX.fill();

	//draw any samples stored in an INFO object:
	if ('INFO' in sampler) {
		CTX.beginPath();
		for (let s of sampler.INFO.samples) {
			let x = xToCanvas(s, Width);
			let y0 = yToCanvas(MIN_Y, Height);
			let y1 = yToCanvas(MAX_Y, Height);
			CTX.moveTo(x, y0);
			CTX.lineTo(x, y1);
		}
		CTX.strokeStyle = '#8808';
		CTX.stroke();
	}

	CTX.restore();
}

function drawFunction(CTX, f, style, Width, Height, DX, DY) {
	CTX.save();

	CTX.beginPath();
	CTX.strokeStyle = style;
	CTX.moveTo(xToCanvas(MIN_X, Width), yToCanvas(f(MIN_X), Height));
	for (let x = MIN_X + DX; x <= MAX_X; x += DX) {
		CTX.lineTo(xToCanvas(x, Width), yToCanvas(f(x), Height));
	}
	CTX.stroke();

	CTX.restore();
}

function drawBounds(CTX, lo, hi, Width, Height) {
	CTX.save();

	CTX.strokeStyle = BOUNDS_COLOR;
	CTX.fillStyle = BOUNDS_COLOR;
	CTX.font = LABEL_FONT;

	CTX.beginPath();
	CTX.moveTo(xToCanvas(lo, Width), 0);
	CTX.lineTo(xToCanvas(lo, Width), Height);
	CTX.stroke();
	CTX.fillText(`a = ${lo}`, xToCanvas(lo, Width) + 5, 15);

	CTX.beginPath();
	CTX.moveTo(xToCanvas(hi, Width), 0);
	CTX.lineTo(xToCanvas(hi, Width), Height);
	CTX.stroke();
	CTX.fillText(`b = ${hi}`, xToCanvas(hi, Width) + 5, 15);

	CTX.restore();
}

// TODO: change this very bad hard-coding
function drawLegend(CTX, Width, Height) {
	let w = 0.3 * Width;
	let h = 0.1 * Height;
	let cx = 0.5 * (Width - w);
	let cy = Height - h;

	CTX.save();

	CTX.beginPath();
	CTX.rect(cx, cy, w, h);
	CTX.fillStyle = "white";
	CTX.fill()
	CTX.stroke();

	CTX.beginPath();
	CTX.strokeStyle = F_COLOR;
	CTX.moveTo(cx + 0.5 * w - 60 , cy + 0.5 * h);
	CTX.lineTo(cx + 0.5 * w - 40, cy + 0.5 * h);
	CTX.stroke();
	CTX.font = LABEL_FONT;
	CTX.fillStyle = "black";
	CTX.fillText("f", cx + 0.5 * w - 30, cy + 0.7 * h);

	CTX.beginPath();
	CTX.strokeStyle = PDF_COLOR;
	CTX.moveTo(cx + 0.5 * w + 10, cy + 0.5 * h);
	CTX.lineTo(cx + 0.5 * w + 30, cy + 0.5 * h);
	CTX.stroke();
	CTX.font = LABEL_FONT;
	CTX.fillStyle = "black";
	CTX.fillText("pdf", cx + 0.5 * w + 40, cy + 0.7 * h);

	CTX.restore();
}


window.onload = init;


</script>
</body>
</html>
